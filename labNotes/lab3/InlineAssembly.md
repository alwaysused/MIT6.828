# Inline Assembly [x]

## Basic

```c
asm ("nop");
asm ("sti");
asm ("pushl %eax\n\t"
     "movl $0, %eax\n\t"
     "popl %eax");
```

`\n\t` is needed so the `.s` file generated by gcc is right if there're multiple statements per asm.

Reason for inline assembly: issuing instructions for which there is no equivalent in C and **don't touch the registers**.

If the inline assembly do touch the registers without fixing things at the end of the asm statements, it's likely you'll get unexpected behavior. Doing so might corrupt values in the register.



## Extended inline assembly

```
asm ( assembpler_template
    : output_operands                   (optional)
    : input_operands                    (optional)
    : clobbered_registers	            (optional)
    );
```

### Assembler template

Assembler template is GAS(GNU Assembler)-compatible code, except when you have *constraint*s, the register names must start with %% instead of %. Assembler template uses AT&Tsyntax. The reason for using %% is that: you can use C variables in inline assembly. GCC names the variables %0, %1, etc, starting from the first variable mentioned in the input/output operand sections. The %% syntax helps GCC differentiate between registers and parameters.

### Output operands

Format: `"constraint"(C expression)`. The output operands is used to tell the assembler how to handle C variables used to store output from the ASM code. Each output operand is a pair of a string literal and a C variable in parenthesis. The string literal, called "constraint", states where the C variable should be mapped. In the constraints, letters represent registers:

```
a        eax
b        ebx
c        ecx
d        edx
S        esi
D        edi
I        constant value (0 to 31)
q,r      dynamically allocated register
g        eax, ebx, ecx, edx or variable in memory
A        eax and edx combined into a 64-bit integer (use long longs)
```

An equation sign means the assembly code doesn't care about the initial value of the mapped variable. 

### Input operands

Input operands are used to pass value from C variable to asm blocks. Again, string literals, aka constraints, are used. 





### Examples

```c
asm ("rep stosl"
     : /* no output registers */
     : "c" (count), "a" (fill_value), "D" (dest)
     : "%ecx", "%edi" );
```

`rep stosl` means storing %exc times the longword in %eax to [%es:%edi] (logical address). So the above code means storing `fill_value` `count` times into `dest`. Input operands specify what should be loaded into registers before executing the assembly template. `: "%ecx", "%edi"` indicates to GCC that the values in the two registers can be corrupted after the asm.



```c
int i;
asm( "movl $0, %0"
   : "=a" (i)
    );
```

The above code means setting %eax to 0.



```c
int i = 4;
asm( "movl %0, %%eax"
   :
   : "b" (i)
   : "eax"
    );
```

The above code moves the value of `i`, which is 4, into %ebx, and then moves the value into %eax. `"b" (i)` means moving the value of `i` into %ebx before executing the assembly template.



```c
int a=10, b;
asm ("movl %1, %%eax; 
     movl %%eax, %0;"
     :"=r"(b)        /* output */
     :"r"(a)         /* input */
     :"%eax"         /* clobbered register */
    );       
```

The above code moves value of `a` into some dynamically allocated register, then moves that value into %eax, then moves that value into `b`. 